#' Convert a graph object to a layout_ggraph object
#'
#' This function takes care of converting the different supported graph
#' representations to a common format. It is called automatically by
#' \code{\link{ggraph}} but can also be used stand-alone to save and reuse
#' layouts. createLayout is an S3 generic with methods for the different
#' supported object.
#'
#' @details
#' \strong{Dendrogram objects}
#'
#' The \code{\link[stats]{dendrogram}} class is used to store binary tree from
#' e.g. hierarchical clustering. The layouts provided for this class is
#' constrained to tree-like representations and include:
#'
#' \describe{
#'   \item{dendrogram}{Uses the heights already defined in the dendrogram
#'   object. See \code{\link{layout_dendrogram_dendrogram}} for further details}
#'   \item{even}{Ignores the heights given by the dendrogram object and instead
#'   spreads the branch points out with an even distance. See
#'   \code{\link{layout_dendrogram_even}} for further details}
#' }
#'
#' \strong{igraph objects}
#'
#' Any type of regular graph/network data can be represented as an igraph
#' object. Because of this the different layouts that can be applied to igraph
#' objects are quite diverse, but not all layouts makes sense to all types of
#' graphs. It is up to the user to understand their data and choose an
#' appropriate layout. For standard node-edge diagrams igraph itself defines a
#' long range of different layout functions that are all available through the
#' \code{igraph} layout. Furthermore ggraph itself defines additional layouts:
#'
#' \describe{
#'   \item{igraph}{Use one of the internal igraph layout algorithms.
#'   The algorithm is specified using the \code{algorithm} argument. See
#'   \code{\link{layout_igraph_igraph}} for further details}
#'   \item{dendrogram}{Lays out the nodes in a tree-like graph as a dendrogram
#'   with leaves set at 0. See \code{\link{layout_igraph_dendrogram}} for
#'   further details}
#'   \item{manual}{Lets the user manually specify the location of each node by
#'   supplying a data.frame with an \code{x} and \code{y} column. See
#'   \code{\link{layout_igraph_manual}} for further details}
#'   \item{linear}{Arranges the nodes linearly in order to make an arc diagram.
#'   See \code{\link{layout_igraph_linear}} for further details}
#'   \item{treemap}{Creates a treemap from the graph, possibly forcing the graph
#'   into a tree structure if it isn't already. See
#'   \code{\link{layout_igraph_treemap}} for further details}
#' }
#'
#' @param graph The object representing the graph. Currently supported classes
#' are igraph and dendrogram
#'
#' @param layout The layout to apply the range depends on the class of graph.
#' See details.
#'
#' @param circular Should the layout be transformed into a circular
#' representation afterward. Only meaningful for a subset of layouts.
#'
#' @param ... Arguments passed on to the specific method
#'
#' @return An object inherting from \code{layout_ggraph}. \code{layout_ggraph}
#' itself inherits from \code{data.frame} and can be considered as such. The
#' data.frame contains the node positions in the \code{x} and \code{y} column
#' along with additional columns generated by the specific layout, as well as
#' node parameters inherited from the graph. Additional information is stored as
#' attributes to the data.frame. The original graph object is stored in the
#' \code{graph} attribute and the \code{circular} attribute contains a logical
#' indicating whether the layout has been transformed to a circular
#' representation.
#'
#' @seealso \code{\link{gEdges}} for extracting edge information from the
#' layout.
#'
#' @examples
#' require(igraph)
#' gr <- make_graph('bull')
#' layout <- createLayout(gr, layout = 'igraph', algorithm = 'kk')
#'
#' @export
createLayout <- function(graph, layout, circular, ...) {
    UseMethod('createLayout', graph)
}
#' @rdname createLayout
#' @export
createLayout.default <- function(graph, layout, ...) {
    stop('No layout function defined for objects of class ', class(graph))
}
checkLayout <- function(layout) {
    if (!inherits(layout, 'data.frame')) {
        stop('layout must subclass data.frame', call. = FALSE)
    }
    if (!all(c('x', 'y', 'circular') %in% names(layout))) {
        stop('layout must contain the columns x, y and circular', call. = FALSE)
    }
    if (!is.logical(layout$circular)) {
        stop('circular column must be logical', call. = FALSE)
    }
    layout
}
